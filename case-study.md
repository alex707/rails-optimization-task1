# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: время выполнения скрипта

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за 24 секунды.

Вот как я построил `feedback_loop`: запускал выполнение скрипта с каждым из профайлеров, находил точки роста, которые можно улучшить, вносил позитивные изменения в код для оптимизации узкого места.

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался stackprof, rubyprof, rbspy

Вот какие проблемы удалось найти и решить

### 1. `RubyProf::FlatPrinter` показал, что самое многочисленное - это `select` по массиву.
При старте скрипта с 10_000 записей файле получается вот такой результат:
`select` каждый раз пробегается по огромному массиву из сессий, когда их выбирает для конкретного пользователя.
Т.е. это значит, что сколько пользователей, столько раз он и пробежится по массиву.
```
Total: 5.016776
Sort by: self_time

 %self      total      self      wait     child     calls  name                           location
 87.11      4.370     4.370     0.000     0.000     1536   Array#select
  7.63      4.982     0.383     0.000     4.600    10010  *Array#each
  1.00      0.122     0.050     0.000     0.072    16898   Array#map
  0.92      0.046     0.046     0.000     0.000    20001   String#split
```
Вынесу сохранение сессий в блок с парсингом файла. туда же, куда сохраняю студентов.
Стало:
```
Total: 0.616663
Sort by: self_time

 %self      total      self      wait     child     calls  name                           location
 60.43      0.583     0.373     0.000     0.211    10010  *Array#each
  8.40      0.052     0.052     0.000     0.000    20001   String#split
  7.39      0.123     0.046     0.000     0.077    16898   Array#map
  5.90      0.066     0.036     0.000     0.030     8464   <Class::Date>#parse
```



## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с ∞ до 24 сек и уложиться в заданный бюджет.

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*
